#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

// String concatenation function
// Signature: char* string_concat(char* str1, char* str2)
// Returns: A newly allocated string containing str1 + str2
char* string_concat(char* str1, char* str2) {
    if (!str1) str1 = "";
    if (!str2) str2 = "";
    
    size_t len1 = strlen(str1);
    size_t len2 = strlen(str2);
    size_t total_len = len1 + len2 + 1; // +1 for null terminator
    
    char* result = (char*)malloc(total_len);
    if (!result) {
        fprintf(stderr, "Memory allocation failed in string_concat\n");
        exit(1);
    }
    
    strcpy(result, str1);
    strcat(result, str2);
    
    return result;
}

// Simple runtime exception handling
void __throw_exception(void* exception_value) {
    printf("Exception thrown: %p\n", exception_value);
    exit(1); // Simple termination for now
}

void __rethrow_exception(void) {
    printf("Re-throwing exception\n");
    exit(1); // Simple termination for now
}

// Array length function
// Signature: int array_length(void* array_ptr)
// Returns: The length of the array (first i32 field)
int array_length(void* array_ptr) {
    if (!array_ptr) {
        fprintf(stderr, "Error: array_length called with null pointer\n");
        exit(3); // Exit code 3 for null pointer
    }
    
    // The array structure is { i32 length, [N x elementType] data }
    // We need to read the first i32 field (length)
    int* length_ptr = (int*)array_ptr;
    int length = *length_ptr;
    
    printf("DEBUG: array_length called with ptr=%p, length=%d\n", array_ptr, length);
    return length;
}

// Type conversion functions for template literals

// Convert number to string
// Signature: char* number_to_string(double value)
// Returns: A newly allocated string representation of the number
char* number_to_string(double value) {
    // Allocate buffer for the string representation
    // Use snprintf to safely convert double to string
    char* buffer = (char*)malloc(32); // 32 chars should be enough for most doubles
    if (!buffer) {
        fprintf(stderr, "Memory allocation failed in number_to_string\n");
        exit(1);
    }
    
    // Convert double to string
    snprintf(buffer, 32, "%.6g", value); // Use %g for compact representation
    
    return buffer;
}

// Convert boolean to string
// Signature: char* boolean_to_string(bool value)
// Returns: A newly allocated string representation of the boolean
char* boolean_to_string(bool value) {
    char* result = (char*)malloc(value ? 5 : 6); // "true" or "false"
    if (!result) {
        fprintf(stderr, "Memory allocation failed in boolean_to_string\n");
        exit(1);
    }
    
    strcpy(result, value ? "true" : "false");
    return result;
}

// Convert object to string (placeholder implementation)
// Signature: char* object_to_string(void* obj)
// Returns: A newly allocated string representation of the object
char* object_to_string(void* obj) {
    if (!obj) {
        char* result = (char*)malloc(5); // "null"
        if (!result) {
            fprintf(stderr, "Memory allocation failed in object_to_string\n");
            exit(1);
        }
        strcpy(result, "null");
        return result;
    }
    
    // For now, return a placeholder string with the object address
    char* result = (char*)malloc(32);
    if (!result) {
        fprintf(stderr, "Memory allocation failed in object_to_string\n");
        exit(1);
    }
    
    snprintf(result, 32, "[object %p]", obj);
    return result;
}

// Global constants for JavaScript built-ins
double Infinity = 1.0 / 0.0;  // Positive infinity
double NaN = 0.0 / 0.0;        // Not a Number

// BasicArrayOperations specialized method implementations
// Note: These functions are generated by the compiler, so we don't need to define them here
// The compiler generates the specialized versions based on the class definition

// Mangled versions of number_to_string for different type contexts
// These functions provide the same functionality as number_to_string but with different mangled names
char* number_to_string_1(double value) {
    return number_to_string(value);
}

char* number_to_string_4(double value) {
    return number_to_string(value);
}

char* number_to_string_5(double value) {
    return number_to_string(value);
}

char* number_to_string_6(double value) {
    return number_to_string(value);
}

char* number_to_string_7(double value) {
    return number_to_string(value);
}

char* number_to_string_8(double value) {
    return number_to_string(value);
}

char* number_to_string_9(double value) {
    return number_to_string(value);
}

// Array push function
// Signature: void arrayPush(void* array_ptr, void* item)
// Adds an item to the end of the array
void arrayPush(void* array_ptr, void* item) {
    printf("DEBUG: arrayPush ENTRY - array_ptr=%p, item=%p\n", array_ptr, item);
    if (!array_ptr) {
        fprintf(stderr, "Error: arrayPush called with null array pointer\n");
        exit(3);
    }
    printf("DEBUG: arrayPush - array_ptr is not null, proceeding...\n");
    
    // The array structure is { i32 length, [N x elementType] data }
    // We need to increment the length and store the item at the new position
    int* length_ptr = (int*)array_ptr;
    printf("DEBUG: arrayPush - length_ptr=%p\n", length_ptr);
    int current_length = *length_ptr;
    
    printf("DEBUG: arrayPush called with array=%p, item=%p, current_length=%d\n", array_ptr, item, current_length);
    
    // For now, this is a placeholder implementation
    // In a full implementation, we would:
    // 1. Check if the array has space for another item
    // 2. Store the item at the appropriate position
    // 3. Increment the length
    // For now, just increment the length as a proof of concept
    *length_ptr = current_length + 1;
    
    printf("DEBUG: arrayPush updated length to %d\n", *length_ptr);
}

// Array pop function
// Signature: void* arrayPop(void* array_ptr)
// Removes and returns the last item from the array
void* arrayPop(void* array_ptr) {
    if (!array_ptr) {
        fprintf(stderr, "Error: arrayPop called with null array pointer\n");
        exit(3);
    }
    
    // The array structure is { i32 length, [N x elementType] data }
    int* length_ptr = (int*)array_ptr;
    int current_length = *length_ptr;
    
    printf("DEBUG: arrayPop called with array=%p, current_length=%d\n", array_ptr, current_length);
    
    if (current_length <= 0) {
        printf("DEBUG: arrayPop called on empty array, returning null\n");
        return NULL;
    }
    
    // For now, this is a placeholder implementation
    // In a full implementation, we would:
    // 1. Get the item at the last position
    // 2. Decrement the length
    // 3. Return the item
    // For now, just decrement the length and return a placeholder
    *length_ptr = current_length - 1;
    
    printf("DEBUG: arrayPop updated length to %d\n", *length_ptr);
    
    // Return a placeholder value (in a real implementation, this would be the actual item)
    return (void*)0x12345678; // Placeholder address
}

// Assembly aliases for mangled names with dots
// These create symbols with dots in the name that the linker expects
__asm__(".weak number_to_string.1");
__asm__(".set number_to_string.1, number_to_string_1");
__asm__(".weak number_to_string.4");
__asm__(".set number_to_string.4, number_to_string_4");
__asm__(".weak number_to_string.5");
__asm__(".set number_to_string.5, number_to_string_5");
__asm__(".weak number_to_string.6");
__asm__(".set number_to_string.6, number_to_string_6");
__asm__(".weak number_to_string.7");
__asm__(".set number_to_string.7, number_to_string_7");
__asm__(".weak number_to_string.8");
__asm__(".set number_to_string.8, number_to_string_8");
__asm__(".weak number_to_string.9");
__asm__(".set number_to_string.9, number_to_string_9");
__asm__(".weak number_to_string.11");
__asm__(".set number_to_string.11, number_to_string_7");
__asm__(".weak number_to_string.12");
__asm__(".set number_to_string.12, number_to_string_8");

// Aliases for mangled arrayPush functions
__asm__(".weak arrayPush.6");
__asm__(".set arrayPush.6, arrayPush");
__asm__(".weak arrayPush.9");
__asm__(".set arrayPush.9, arrayPush");
__asm__(".weak arrayPush.10");
__asm__(".set arrayPush.10, arrayPush");
__asm__(".weak arrayPush.11");
__asm__(".set arrayPush.11, arrayPush");

// Function definitions for mangled malloc functions
void* malloc_9(size_t size) {
    return malloc(size);
}

void* malloc_10(size_t size) {
    return malloc(size);
}

void* malloc_11(size_t size) {
    return malloc(size);
}

void* malloc_12(size_t size) {
    return malloc(size);
}

void* malloc_13(size_t size) {
    return malloc(size);
}

void* malloc_14(size_t size) {
    return malloc(size);
}

void* malloc_15(size_t size) {
    return malloc(size);
}

void* malloc_16(size_t size) {
    return malloc(size);
}

// Aliases for mangled malloc functions
__asm__(".weak malloc.9");
__asm__(".set malloc.9, malloc_9");
__asm__(".weak malloc.10");
__asm__(".set malloc.10, malloc_10");
__asm__(".weak malloc.11");
__asm__(".set malloc.11, malloc_11");
__asm__(".weak malloc.12");
__asm__(".set malloc.12, malloc_12");
__asm__(".weak malloc.13");
__asm__(".set malloc.13, malloc_13");
__asm__(".weak malloc.14");
__asm__(".set malloc.14, malloc_14");
__asm__(".weak malloc.15");
__asm__(".set malloc.15, malloc_15");
__asm__(".weak malloc.16");
__asm__(".set malloc.16, malloc_16");

// Additional number_to_string aliases
__asm__(".weak number_to_string.13");
__asm__(".set number_to_string.13, number_to_string_7");